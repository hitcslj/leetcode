'''
连续空闲内存合并管理
动态内存管理根据用户的需求分配任意大小的内存，当用户释放内存时，被释放的内存回到池(堆)中供其他用户使用。
现设计某实时操作系统计划的内存管理功能，请你实现被释放内存的回收合并模块，当经过一次内存释放操作后，
请返回当前最大的连续内存块的起始位置，以及此连续内存的数量(块数)。
若存在多个最大连续内存块，则返回编号最小的内存块信息。当前已经把连续内存，按块进行连续编号。

解答要求
时间限制:C/C++1000ms,其他语言:2000ms 内存限制:C/C++256MB其他语言:512MB
输入
输入:1,3,2,5 表示释放四块内存，ID分别为1.3.2.5，每块内存的大小为1个单位[预制条件]
函数执行前，所有内存均已被申请完毕，无空闲，不需考虑内存重复释放[取值范围]
内存ID编号:0<ID<2^31-1，单次释放的内存个数<10000
输出
输出：1,3 经过回收处理后，当前可用的最大连续内存大小3，以及此内存的起始编号1. 
说明:1,3,2,5四块内存，前面三块1,3,2为连续内存，合并后的连续内存数为3个单位起始编号为1，因此返回1,3

example:
input:
2,4,3,7,6
output:
2,3

'''


def main():
    nums = list(map(int, input().split(',')))
    nums.sort()
    # 找出连续数字的最大个数
    max_count = 1
    count = 1
    start = nums[0]
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            count += 1
            if count > max_count:
                max_count = count
                start = nums[i - count + 1]
        else:
            count = 1
    print(f'{start},{max_count}')

if __name__ == '__main__':
    main()